LiSP の息抜きにちょっこと Forth でも作ってみる。

Direct threaded code
64bit Linux

もとは jonesforth です。
http://annexia.org/forth


p *(char*)($rdi)@$rcx
p/x *(char*)($rdi-24)@24

%rax Return value
%rbx Callee saved
%rcx 4th argument
%rdx 3rd argument
%rsi 2nd argument
%rdi 1st argument
%rbp Callee saved
%rsp Stack pointer
%r8  5th argument
%r9  6th argument
%r10 Callee saved
%r11 Used for linking
%r12 Unused for C
%r13 Callee saved
%r14 Callee saved
%r15 Callee saved


<<Direct Threaded Code>>
mov      r15,     _ENTER

_ENTER:
        PUSHRSP rsi
        pop     rsi
        NEXT

DOUBLE:
        nop
        nop
        nop
        nop
        nop
        call    r15
.code:
        DUP
        PLUS
        EXIT
DUP:
        mov     rax,    rsp
        push    rax
        NEXT
EXIT:
        POPRSP  rsi
        NEXT

<<Indirect Threaded Code>>
DOUBLE:
        DOCOL                   ; codeword
        DUP
        PLUS
        EXIT
DUP:
        DUP_code                ; codeword
DUP_code:
        mov     rax,    rsp
        push    rax
        NEXT
EXIT:
        EXIT_code               ; codeword
EXIT_code:
        POPRSP  rsi
        NEXT
DOCOL:
        PUSHRSP rsi
        add     rax,    CELLL
        mov     rsi,    rax
        NEXT



: one
(gdb) p/x *(char*)($rdx)@32
$8 = {0xc8, 0x10, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x6f, 0x6e, 0x65, 0x0, 0x0, 0x0, 0x90, 0x90, 0x90, 0xe8, 0xb8, 0xf3, 0xff, 0xff, 0x28, 0x8, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0}

defword hello
(gdb) p/x *(char*)($rdx)@32
$11 = {0x88, 0xe, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x90, 0x90, 0x90, 0x90, 0xe8, 0xd8, 0xf1, 0xff, 0xff, 0x18, 0xe, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0}

e8 は relative だ。ff を使う必要あり。